# AWS Deployment Plan for Visual-ML

## Executive Summary

Deploy Visual-ML application to AWS using containerized services with automated CI/CD pipeline triggered on every push to `main` branch.

**AWS Services:**
- **ECS Fargate**: Container orchestration (frontend, backend, celery)
- **ECR**: Private Docker image registry
- **RDS PostgreSQL**: Managed database
- **ElastiCache Redis**: Managed cache/message broker
- **Application Load Balancer**: Traffic distribution
- **S3**: File storage (uploads, models)
- **CloudWatch**: Logging and monitoring
- **Secrets Manager**: Secure credential storage

**CI/CD:** GitHub Actions → Build → Push to ECR → Deploy to ECS (zero-downtime)

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                     AWS Cloud (us-east-1)                    │
│                                                               │
│  ┌────────────────────────────────────────────────────────┐ │
│  │                  Application Load Balancer              │ │
│  │              (HTTPS with ACM Certificate)               │ │
│  └─────────────┬──────────────────────┬───────────────────┘ │
│                │                      │                       │
│  ┌─────────────▼──────────┐  ┌───────▼──────────────────┐  │
│  │   ECS Service           │  │   ECS Service            │  │
│  │   (Frontend)            │  │   (Backend)              │  │
│  │   - Nginx + React       │  │   - FastAPI + Uvicorn    │  │
│  │   - 2 tasks             │  │   - 2 tasks (autoscale)  │  │
│  └─────────────────────────┘  └──────────┬───────────────┘  │
│                                           │                   │
│  ┌────────────────────────────────────────▼───────────────┐ │
│  │              ECS Service (Celery Workers)              │ │
│  │              - Background tasks                        │ │
│  │              - 2 tasks                                 │ │
│  └────────────────────────────────────────────────────────┘ │
│                                                               │
│  ┌──────────────────┐  ┌──────────────────┐  ┌───────────┐ │
│  │  RDS PostgreSQL  │  │ ElastiCache Redis│  │    S3     │ │
│  │  (Multi-AZ)      │  │  (Cluster mode)  │  │  Bucket   │ │
│  └──────────────────┘  └──────────────────┘  └───────────┘ │
│                                                               │
│  ┌──────────────────┐  ┌──────────────────┐                 │
│  │ Secrets Manager  │  │   CloudWatch     │                 │
│  │  (Credentials)   │  │  (Logs/Metrics)  │                 │
│  └──────────────────┘  └──────────────────┘                 │
└───────────────────────────────────────────────────────────────┘
```

---

## Phase 1: AWS Infrastructure Setup

### 1.1 Create VPC and Networking

```bash
# Create VPC with public and private subnets
aws ec2 create-vpc --cidr-block 10.0.0.0/16 --tag-specifications 'ResourceType=vpc,Tags=[{Key=Name,Value=visualml-vpc}]'

# Create subnets (2 public, 2 private across 2 AZs)
# Public Subnet 1 (us-east-1a)
aws ec2 create-subnet --vpc-id <VPC_ID> --cidr-block 10.0.1.0/24 --availability-zone us-east-1a

# Public Subnet 2 (us-east-1b)
aws ec2 create-subnet --vpc-id <VPC_ID> --cidr-block 10.0.2.0/24 --availability-zone us-east-1b

# Private Subnet 1 (us-east-1a)
aws ec2 create-subnet --vpc-id <VPC_ID> --cidr-block 10.0.10.0/24 --availability-zone us-east-1a

# Private Subnet 2 (us-east-1b)
aws ec2 create-subnet --vpc-id <VPC_ID> --cidr-block 10.0.11.0/24 --availability-zone us-east-1b

# Create Internet Gateway
aws ec2 create-internet-gateway --tag-specifications 'ResourceType=internet-gateway,Tags=[{Key=Name,Value=visualml-igw}]'
aws ec2 attach-internet-gateway --vpc-id <VPC_ID> --internet-gateway-id <IGW_ID>

# Create NAT Gateway (for private subnets to access internet)
aws ec2 allocate-address --domain vpc
aws ec2 create-nat-gateway --subnet-id <PUBLIC_SUBNET_1_ID> --allocation-id <EIP_ID>
```

### 1.2 Create ECR Repositories

```bash
# Create repositories for Docker images
aws ecr create-repository --repository-name visualml-frontend --region us-east-1
aws ecr create-repository --repository-name visualml-backend --region us-east-1

# Enable image scanning
aws ecr put-image-scanning-configuration \
  --repository-name visualml-frontend \
  --image-scanning-configuration scanOnPush=true

aws ecr put-image-scanning-configuration \
  --repository-name visualml-backend \
  --image-scanning-configuration scanOnPush=true

# Set lifecycle policy (keep last 10 images)
aws ecr put-lifecycle-policy \
  --repository-name visualml-frontend \
  --lifecycle-policy-text file://ecr-lifecycle-policy.json
```

### 1.3 Create RDS PostgreSQL Database

```bash
# Create DB subnet group
aws rds create-db-subnet-group \
  --db-subnet-group-name visualml-db-subnet \
  --db-subnet-group-description "Visual ML Database Subnet Group" \
  --subnet-ids <PRIVATE_SUBNET_1_ID> <PRIVATE_SUBNET_2_ID>

# Create security group for RDS
aws ec2 create-security-group \
  --group-name visualml-rds-sg \
  --description "Security group for Visual ML RDS" \
  --vpc-id <VPC_ID>

# Allow PostgreSQL access from ECS tasks
aws ec2 authorize-security-group-ingress \
  --group-id <RDS_SG_ID> \
  --protocol tcp \
  --port 5432 \
  --source-group <ECS_SG_ID>

# Create RDS instance (Multi-AZ for production)
aws rds create-db-instance \
  --db-instance-identifier visualml-db \
  --db-instance-class db.t3.medium \
  --engine postgres \
  --engine-version 15.4 \
  --master-username visualml_admin \
  --master-user-password <SECURE_PASSWORD> \
  --allocated-storage 20 \
  --storage-type gp3 \
  --db-subnet-group-name visualml-db-subnet \
  --vpc-security-group-ids <RDS_SG_ID> \
  --backup-retention-period 7 \
  --multi-az \
  --storage-encrypted \
  --publicly-accessible false
```

### 1.4 Create ElastiCache Redis Cluster

```bash
# Create cache subnet group
aws elasticache create-cache-subnet-group \
  --cache-subnet-group-name visualml-redis-subnet \
  --cache-subnet-group-description "Visual ML Redis Subnet Group" \
  --subnet-ids <PRIVATE_SUBNET_1_ID> <PRIVATE_SUBNET_2_ID>

# Create security group for Redis
aws ec2 create-security-group \
  --group-name visualml-redis-sg \
  --description "Security group for Visual ML Redis" \
  --vpc-id <VPC_ID>

# Allow Redis access from ECS tasks
aws ec2 authorize-security-group-ingress \
  --group-id <REDIS_SG_ID> \
  --protocol tcp \
  --port 6379 \
  --source-group <ECS_SG_ID>

# Create Redis cluster
aws elasticache create-cache-cluster \
  --cache-cluster-id visualml-redis \
  --cache-node-type cache.t3.medium \
  --engine redis \
  --engine-version 7.0 \
  --num-cache-nodes 1 \
  --cache-subnet-group-name visualml-redis-subnet \
  --security-group-ids <REDIS_SG_ID> \
  --auth-token <REDIS_PASSWORD> \
  --transit-encryption-enabled
```

### 1.5 Create S3 Bucket

```bash
# Create S3 bucket for uploads and models
aws s3 mb s3://visualml-storage-prod --region us-east-1

# Enable versioning
aws s3api put-bucket-versioning \
  --bucket visualml-storage-prod \
  --versioning-configuration Status=Enabled

# Enable encryption
aws s3api put-bucket-encryption \
  --bucket visualml-storage-prod \
  --server-side-encryption-configuration '{
    "Rules": [{
      "ApplyServerSideEncryptionByDefault": {
        "SSEAlgorithm": "AES256"
      }
    }]
  }'

# Set lifecycle policy
aws s3api put-bucket-lifecycle-configuration \
  --bucket visualml-storage-prod \
  --lifecycle-configuration file://s3-lifecycle-policy.json
```

### 1.6 Store Secrets in AWS Secrets Manager

```bash
# Create secret for database credentials
aws secretsmanager create-secret \
  --name visualml/database \
  --secret-string '{
    "username": "visualml_admin",
    "password": "<SECURE_PASSWORD>",
    "engine": "postgres",
    "host": "<RDS_ENDPOINT>",
    "port": 5432,
    "dbname": "visualml_prod"
  }'

# Create secret for Redis
aws secretsmanager create-secret \
  --name visualml/redis \
  --secret-string '{
    "password": "<REDIS_PASSWORD>",
    "host": "<REDIS_ENDPOINT>",
    "port": 6379
  }'

# Create secret for application secrets
aws secretsmanager create-secret \
  --name visualml/app \
  --secret-string '{
    "SECRET_KEY": "<64_CHAR_SECRET>",
    "BREVO_API_KEY": "<BREVO_KEY>",
    "GOOGLE_CLIENT_ID": "<GOOGLE_ID>",
    "GOOGLE_CLIENT_SECRET": "<GOOGLE_SECRET>"
  }'
```

---

## Phase 2: ECS Cluster Setup

### 2.1 Create ECS Cluster

```bash
# Create ECS cluster (Fargate)
aws ecs create-cluster \
  --cluster-name visualml-cluster \
  --capacity-providers FARGATE FARGATE_SPOT \
  --default-capacity-provider-strategy \
    capacityProvider=FARGATE,weight=1 \
    capacityProvider=FARGATE_SPOT,weight=4
```

### 2.2 Create IAM Roles

**Task Execution Role** (for ECS to pull images and access secrets):

```bash
# Create trust policy
cat > ecs-task-execution-trust-policy.json <<EOF
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": {"Service": "ecs-tasks.amazonaws.com"},
    "Action": "sts:AssumeRole"
  }]
}
EOF

# Create role
aws iam create-role \
  --role-name visualml-task-execution-role \
  --assume-role-policy-document file://ecs-task-execution-trust-policy.json

# Attach AWS managed policy
aws iam attach-role-policy \
  --role-name visualml-task-execution-role \
  --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy

# Add Secrets Manager access
aws iam put-role-policy \
  --role-name visualml-task-execution-role \
  --policy-name SecretsManagerAccess \
  --policy-document '{
    "Version": "2012-10-17",
    "Statement": [{
      "Effect": "Allow",
      "Action": [
        "secretsmanager:GetSecretValue",
        "kms:Decrypt"
      ],
      "Resource": "*"
    }]
  }'
```

**Task Role** (for application to access AWS services):

```bash
# Create task role
aws iam create-role \
  --role-name visualml-task-role \
  --assume-role-policy-document file://ecs-task-execution-trust-policy.json

# Add S3 access policy
aws iam put-role-policy \
  --role-name visualml-task-role \
  --policy-name S3Access \
  --policy-document '{
    "Version": "2012-10-17",
    "Statement": [{
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject",
        "s3:DeleteObject",
        "s3:ListBucket"
      ],
      "Resource": [
        "arn:aws:s3:::visualml-storage-prod",
        "arn:aws:s3:::visualml-storage-prod/*"
      ]
    }]
  }'
```

### 2.3 Create Application Load Balancer

```bash
# Create security group for ALB
aws ec2 create-security-group \
  --group-name visualml-alb-sg \
  --description "Security group for Visual ML ALB" \
  --vpc-id <VPC_ID>

# Allow HTTP and HTTPS
aws ec2 authorize-security-group-ingress \
  --group-id <ALB_SG_ID> \
  --protocol tcp \
  --port 80 \
  --cidr 0.0.0.0/0

aws ec2 authorize-security-group-ingress \
  --group-id <ALB_SG_ID> \
  --protocol tcp \
  --port 443 \
  --cidr 0.0.0.0/0

# Create ALB
aws elbv2 create-load-balancer \
  --name visualml-alb \
  --subnets <PUBLIC_SUBNET_1_ID> <PUBLIC_SUBNET_2_ID> \
  --security-groups <ALB_SG_ID> \
  --scheme internet-facing \
  --type application

# Create target groups
# Frontend target group
aws elbv2 create-target-group \
  --name visualml-frontend-tg \
  --protocol HTTP \
  --port 80 \
  --vpc-id <VPC_ID> \
  --target-type ip \
  --health-check-path / \
  --health-check-interval-seconds 30

# Backend target group
aws elbv2 create-target-group \
  --name visualml-backend-tg \
  --protocol HTTP \
  --port 8000 \
  --vpc-id <VPC_ID> \
  --target-type ip \
  --health-check-path /api/v1/ \
  --health-check-interval-seconds 30

# Create listener (HTTPS)
aws elbv2 create-listener \
  --load-balancer-arn <ALB_ARN> \
  --protocol HTTPS \
  --port 443 \
  --certificates CertificateArn=<ACM_CERT_ARN> \
  --default-actions Type=forward,TargetGroupArn=<FRONTEND_TG_ARN>

# Add rule for backend API
aws elbv2 create-rule \
  --listener-arn <LISTENER_ARN> \
  --priority 1 \
  --conditions Field=path-pattern,Values='/api/*' \
  --actions Type=forward,TargetGroupArn=<BACKEND_TG_ARN>
```

---

## Phase 3: Task Definitions and Services

### 3.1 Backend Task Definition

Create `backend-task-definition.json`:

```json
{
  "family": "visualml-backend",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "1024",
  "memory": "2048",
  "executionRoleArn": "arn:aws:iam::<ACCOUNT_ID>:role/visualml-task-execution-role",
  "taskRoleArn": "arn:aws:iam::<ACCOUNT_ID>:role/visualml-task-role",
  "containerDefinitions": [
    {
      "name": "backend",
      "image": "<ACCOUNT_ID>.dkr.ecr.us-east-1.amazonaws.com/visualml-backend:latest",
      "essential": true,
      "portMappings": [
        {
          "containerPort": 8000,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {"name": "ENVIRONMENT", "value": "production"},
        {"name": "DEBUG", "value": "False"},
        {"name": "ENABLE_CACHE", "value": "True"},
        {"name": "USE_S3", "value": "true"},
        {"name": "S3_BUCKET", "value": "visualml-storage-prod"},
        {"name": "S3_REGION", "value": "us-east-1"}
      ],
      "secrets": [
        {
          "name": "DATABASE_URL",
          "valueFrom": "arn:aws:secretsmanager:us-east-1:<ACCOUNT_ID>:secret:visualml/database:host::"
        },
        {
          "name": "REDIS_URL",
          "valueFrom": "arn:aws:secretsmanager:us-east-1:<ACCOUNT_ID>:secret:visualml/redis:host::"
        },
        {
          "name": "SECRET_KEY",
          "valueFrom": "arn:aws:secretsmanager:us-east-1:<ACCOUNT_ID>:secret:visualml/app:SECRET_KEY::"
        },
        {
          "name": "BREVO_API_KEY",
          "valueFrom": "arn:aws:secretsmanager:us-east-1:<ACCOUNT_ID>:secret:visualml/app:BREVO_API_KEY::"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/visualml-backend",
          "awslogs-region": "us-east-1",
          "awslogs-stream-prefix": "ecs"
        }
      },
      "command": ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "4"]
    }
  ]
}
```

Register task definition:

```bash
aws ecs register-task-definition --cli-input-json file://backend-task-definition.json
```

### 3.2 Frontend Task Definition

Create `frontend-task-definition.json`:

```json
{
  "family": "visualml-frontend",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "512",
  "memory": "1024",
  "executionRoleArn": "arn:aws:iam::<ACCOUNT_ID>:role/visualml-task-execution-role",
  "containerDefinitions": [
    {
      "name": "frontend",
      "image": "<ACCOUNT_ID>.dkr.ecr.us-east-1.amazonaws.com/visualml-frontend:latest",
      "essential": true,
      "portMappings": [
        {
          "containerPort": 80,
          "protocol": "tcp"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/visualml-frontend",
          "awslogs-region": "us-east-1",
          "awslogs-stream-prefix": "ecs"
        }
      }
    }
  ]
}
```

### 3.3 Celery Worker Task Definition

Create `celery-task-definition.json`:

```json
{
  "family": "visualml-celery",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "512",
  "memory": "1024",
  "executionRoleArn": "arn:aws:iam::<ACCOUNT_ID>:role/visualml-task-execution-role",
  "taskRoleArn": "arn:aws:iam::<ACCOUNT_ID>:role/visualml-task-role",
  "containerDefinitions": [
    {
      "name": "celery-worker",
      "image": "<ACCOUNT_ID>.dkr.ecr.us-east-1.amazonaws.com/visualml-backend:latest",
      "essential": true,
      "secrets": [
        {"name": "DATABASE_URL", "valueFrom": "arn:aws:secretsmanager:us-east-1:<ACCOUNT_ID>:secret:visualml/database:host::"},
        {"name": "REDIS_URL", "valueFrom": "arn:aws:secretsmanager:us-east-1:<ACCOUNT_ID>:secret:visualml/redis:host::"}
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/visualml-celery",
          "awslogs-region": "us-east-1",
          "awslogs-stream-prefix": "ecs"
        }
      },
      "command": ["celery", "-A", "app.core.celery_app", "worker", "--loglevel=info", "--concurrency=4"]
    }
  ]
}
```

### 3.4 Create ECS Services

```bash
# Create backend service
aws ecs create-service \
  --cluster visualml-cluster \
  --service-name visualml-backend \
  --task-definition visualml-backend \
  --desired-count 2 \
  --launch-type FARGATE \
  --network-configuration "awsvpcConfiguration={subnets=[<PRIVATE_SUBNET_1>,<PRIVATE_SUBNET_2>],securityGroups=[<ECS_SG>],assignPublicIp=DISABLED}" \
  --load-balancers targetGroupArn=<BACKEND_TG_ARN>,containerName=backend,containerPort=8000 \
  --health-check-grace-period-seconds 60

# Create frontend service
aws ecs create-service \
  --cluster visualml-cluster \
  --service-name visualml-frontend \
  --task-definition visualml-frontend \
  --desired-count 2 \
  --launch-type FARGATE \
  --network-configuration "awsvpcConfiguration={subnets=[<PRIVATE_SUBNET_1>,<PRIVATE_SUBNET_2>],securityGroups=[<ECS_SG>],assignPublicIp=DISABLED}" \
  --load-balancers targetGroupArn=<FRONTEND_TG_ARN>,containerName=frontend,containerPort=80

# Create Celery worker service
aws ecs create-service \
  --cluster visualml-cluster \
  --service-name visualml-celery \
  --task-definition visualml-celery \
  --desired-count 2 \
  --launch-type FARGATE \
  --network-configuration "awsvpcConfiguration={subnets=[<PRIVATE_SUBNET_1>,<PRIVATE_SUBNET_2>],securityGroups=[<ECS_SG>],assignPublicIp=DISABLED}"
```

---

## Phase 4: CI/CD Pipeline with GitHub Actions

### 4.1 Required GitHub Secrets

Add these secrets to your GitHub repository (Settings → Secrets and variables → Actions):

| Secret Name | Description | How to Get |
|-------------|-------------|------------|
| `AWS_ACCOUNT_ID` | Your AWS account ID | AWS Console → Account |
| `AWS_ACCESS_KEY_ID` | IAM user access key | IAM → Users → Security credentials |
| `AWS_SECRET_ACCESS_KEY` | IAM user secret key | IAM → Users → Security credentials |
| `AWS_REGION` | AWS region | `us-east-1` |
| `ECR_BACKEND_REPOSITORY` | ECR repo name | `visualml-backend` |
| `ECR_FRONTEND_REPOSITORY` | ECR repo name | `visualml-frontend` |
| `ECS_CLUSTER` | ECS cluster name | `visualml-cluster` |
| `ECS_BACKEND_SERVICE` | Backend service name | `visualml-backend` |
| `ECS_FRONTEND_SERVICE` | Frontend service name | `visualml-frontend` |
| `ECS_CELERY_SERVICE` | Celery service name | `visualml-celery` |
| `VITE_API_URL` | Frontend API URL | `https://api.yourdomain.com` |

### 4.2 Update GitHub Actions Workflow

Create `.github/workflows/aws-deploy.yml`:

```yaml
name: Deploy to AWS ECS

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com

jobs:
  build-and-deploy:
    name: Build and Deploy to AWS
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push backend image
        env:
          ECR_REPOSITORY: ${{ secrets.ECR_BACKEND_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./server
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Build and push frontend image
        env:
          ECR_REPOSITORY: ${{ secrets.ECR_FRONTEND_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build \
            --build-arg VITE_API_URL=${{ secrets.VITE_API_URL }} \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            ./client
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Deploy backend to ECS
        run: |
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service ${{ secrets.ECS_BACKEND_SERVICE }} \
            --force-new-deployment \
            --region ${{ secrets.AWS_REGION }}

      - name: Deploy frontend to ECS
        run: |
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service ${{ secrets.ECS_FRONTEND_SERVICE }} \
            --force-new-deployment \
            --region ${{ secrets.AWS_REGION }}

      - name: Deploy Celery workers to ECS
        run: |
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service ${{ secrets.ECS_CELERY_SERVICE }} \
            --force-new-deployment \
            --region ${{ secrets.AWS_REGION }}

      - name: Wait for deployment to complete
        run: |
          aws ecs wait services-stable \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --services ${{ secrets.ECS_BACKEND_SERVICE }} ${{ secrets.ECS_FRONTEND_SERVICE }} \
            --region ${{ secrets.AWS_REGION }}

      - name: Run database migrations
        run: |
          # Get backend task ARN
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service-name ${{ secrets.ECS_BACKEND_SERVICE }} \
            --query 'taskArns[0]' \
            --output text)
          
          # Run migrations
          aws ecs execute-command \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --task $TASK_ARN \
            --container backend \
            --command "alembic upgrade head" \
            --interactive

      - name: Notify deployment status
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'AWS ECS deployment ${{ job.status }}'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        continue-on-error: true
```

---

## Phase 5: Frontend Environment Configuration

### 5.1 Update Frontend Dockerfile

Modify [client/Dockerfile](file:///c:/Codes/Visual-ML/client/Dockerfile) to accept build-time API URL:

```dockerfile
# Multi-stage Dockerfile for Visual-ML Frontend
FROM node:20-alpine as builder

WORKDIR /app

# Accept build argument
ARG VITE_API_URL
ENV VITE_API_URL=$VITE_API_URL

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production=false

# Copy source code
COPY . .

# Build the application
RUN npm run build

# Stage 2: Runtime - Serve with nginx
FROM nginx:alpine

# Copy custom nginx configuration
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Copy built assets from builder
COPY --from=builder /app/dist /usr/share/nginx/html

# Add healthcheck
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --quiet --tries=1 --spider http://localhost/ || exit 1

# Expose port
EXPOSE 80

# Start nginx
CMD ["nginx", "-g", "daemon off;"]
```

### 5.2 Update Nginx Configuration

Create/update [client/nginx.conf](file:///c:/Codes/Visual-ML/client/nginx.conf):

```nginx
server {
    listen 80;
    server_name _;
    
    root /usr/share/nginx/html;
    index index.html;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml+rss application/json;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # Cache static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # SPA routing - serve index.html for all routes
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Health check endpoint
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
}
```

---

## Phase 6: Backend Environment Configuration

### 6.1 Update Backend to Use AWS Services

Modify [server/app/core/config.py](file:///c:/Codes/Visual-ML/server/app/core/config.py) to read from environment variables:

```python
import os
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # Database
    DATABASE_URL: str = os.getenv("DATABASE_URL")
    
    # Redis
    REDIS_URL: str = os.getenv("REDIS_URL")
    CELERY_BROKER_URL: str = os.getenv("REDIS_URL")
    CELERY_RESULT_BACKEND: str = os.getenv("REDIS_URL")
    
    # AWS S3
    USE_S3: bool = os.getenv("USE_S3", "false").lower() == "true"
    S3_BUCKET: str = os.getenv("S3_BUCKET", "")
    S3_REGION: str = os.getenv("S3_REGION", "us-east-1")
    AWS_ACCESS_KEY_ID: str = os.getenv("AWS_ACCESS_KEY_ID", "")
    AWS_SECRET_ACCESS_KEY: str = os.getenv("AWS_SECRET_ACCESS_KEY", "")
    
    # Application
    SECRET_KEY: str = os.getenv("SECRET_KEY")
    ENVIRONMENT: str = os.getenv("ENVIRONMENT", "production")
    DEBUG: bool = os.getenv("DEBUG", "False").lower() == "true"
    
    # Email
    BREVO_API_KEY: str = os.getenv("BREVO_API_KEY", "")
    
    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()
```

---

## Phase 7: Monitoring and Logging

### 7.1 CloudWatch Log Groups

```bash
# Create log groups
aws logs create-log-group --log-group-name /ecs/visualml-backend
aws logs create-log-group --log-group-name /ecs/visualml-frontend
aws logs create-log-group --log-group-name /ecs/visualml-celery

# Set retention policy (30 days)
aws logs put-retention-policy --log-group-name /ecs/visualml-backend --retention-in-days 30
aws logs put-retention-policy --log-group-name /ecs/visualml-frontend --retention-in-days 30
aws logs put-retention-policy --log-group-name /ecs/visualml-celery --retention-in-days 30
```

### 7.2 CloudWatch Alarms

```bash
# High CPU alarm
aws cloudwatch put-metric-alarm \
  --alarm-name visualml-backend-high-cpu \
  --alarm-description "Alert when backend CPU exceeds 80%" \
  --metric-name CPUUtilization \
  --namespace AWS/ECS \
  --statistic Average \
  --period 300 \
  --threshold 80 \
  --comparison-operator GreaterThanThreshold \
  --evaluation-periods 2

# High memory alarm
aws cloudwatch put-metric-alarm \
  --alarm-name visualml-backend-high-memory \
  --alarm-description "Alert when backend memory exceeds 80%" \
  --metric-name MemoryUtilization \
  --namespace AWS/ECS \
  --statistic Average \
  --period 300 \
  --threshold 80 \
  --comparison-operator GreaterThanThreshold \
  --evaluation-periods 2
```

---

## Cost Estimation (Monthly)

| Service | Configuration | Estimated Cost |
|---------|---------------|----------------|
| ECS Fargate (Backend) | 2 tasks × 1 vCPU, 2GB RAM | ~$60 |
| ECS Fargate (Frontend) | 2 tasks × 0.5 vCPU, 1GB RAM | ~$30 |
| ECS Fargate (Celery) | 2 tasks × 0.5 vCPU, 1GB RAM | ~$30 |
| RDS PostgreSQL | db.t3.medium, Multi-AZ | ~$70 |
| ElastiCache Redis | cache.t3.medium | ~$50 |
| Application Load Balancer | Standard ALB | ~$20 |
| S3 Storage | 100GB + requests | ~$5 |
| Data Transfer | 500GB outbound | ~$45 |
| CloudWatch Logs | 10GB ingestion | ~$5 |
| **Total** | | **~$315/month** |

---

## Deployment Checklist

### Pre-Deployment
- [ ] AWS account created and configured
- [ ] Domain name registered and DNS configured
- [ ] SSL certificate created in ACM
- [ ] All GitHub secrets configured
- [ ] IAM roles and policies created
- [ ] VPC and networking configured

### Infrastructure Setup
- [ ] ECR repositories created
- [ ] RDS PostgreSQL database created
- [ ] ElastiCache Redis cluster created
- [ ] S3 bucket created with proper permissions
- [ ] Secrets stored in AWS Secrets Manager
- [ ] ECS cluster created
- [ ] Application Load Balancer configured
- [ ] Target groups created

### Application Deployment
- [ ] Task definitions registered
- [ ] ECS services created
- [ ] Initial images pushed to ECR
- [ ] Database migrations run
- [ ] Health checks passing
- [ ] DNS pointing to ALB

### CI/CD Setup
- [ ] GitHub Actions workflow created
- [ ] Workflow tested with manual trigger
- [ ] Auto-deployment on main branch verified

### Post-Deployment
- [ ] CloudWatch alarms configured
- [ ] Monitoring dashboard created
- [ ] Backup strategy implemented
- [ ] SSL/HTTPS working
- [ ] Application accessible via domain

---

## Rollback Procedure

If deployment fails:

```bash
# Revert to previous task definition
aws ecs update-service \
  --cluster visualml-cluster \
  --service visualml-backend \
  --task-definition visualml-backend:PREVIOUS_REVISION

# Or use previous image tag
aws ecs update-service \
  --cluster visualml-cluster \
  --service visualml-backend \
  --force-new-deployment
```

---

## Next Steps

1. **Review this plan** and confirm AWS services selection
2. **Set up AWS account** if not already done
3. **Configure domain and SSL certificate**
4. **Execute Phase 1-3** to set up infrastructure
5. **Test deployment** with GitHub Actions workflow
6. **Monitor and optimize** based on actual usage

---

**Questions to Address:**
1. Do you have an AWS account already?
2. Do you have a domain name for the application?
3. What's your preferred AWS region?
4. Do you need staging environment in addition to production?
5. Any specific compliance requirements (HIPAA, SOC2, etc.)?
