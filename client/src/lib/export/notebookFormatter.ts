/**
 * Jupyter Notebook formatter.
 *
 * Takes the GeneratedPipeline (code blocks + imports) and wraps them
 * into a valid .ipynb JSON document where each node becomes its own
 * code cell with a preceding markdown header cell.
 */

import type { GeneratedPipeline, NotebookDocument, NotebookCell } from "./types";

function makeMarkdownCell(source: string): NotebookCell {
  return {
    cell_type: "markdown",
    source: source.split("\n"),
    metadata: {},
  };
}

function makeCodeCell(source: string): NotebookCell {
  return {
    cell_type: "code",
    source: source.split("\n"),
    metadata: {},
    outputs: [],
    execution_count: null,
  };
}

export function toNotebook(pipeline: GeneratedPipeline): NotebookDocument {
  const cells: NotebookCell[] = [];

  // Title cell
  cells.push(
    makeMarkdownCell(
      "# ML Pipeline\n\nGenerated by **Visual-ML** â€” visual pipeline builder.",
    ),
  );

  // Imports cell
  if (pipeline.imports.length > 0) {
    cells.push(makeCodeCell(pipeline.imports.join("\n")));
  }

  // One markdown + code cell pair per node block
  for (const block of pipeline.blocks) {
    if (!block.code) continue;

    if (block.comment) {
      cells.push(makeMarkdownCell(block.comment));
    }

    cells.push(makeCodeCell(block.code));
  }

  return {
    nbformat: 4,
    nbformat_minor: 5,
    metadata: {
      kernelspec: {
        display_name: "Python 3",
        language: "python",
        name: "python3",
      },
      language_info: {
        name: "python",
        version: "3.10.0",
      },
    },
    cells,
  };
}

/** Serialize a NotebookDocument to a JSON string ready for download */
export function serializeNotebook(doc: NotebookDocument): string {
  return JSON.stringify(doc, null, 1);
}
